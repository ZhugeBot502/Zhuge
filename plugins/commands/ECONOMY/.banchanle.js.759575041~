import axios from 'axios';

const config = {
  name: "even-odd",
  aliases: ["eo"],
  description: "Play even-odd with multiplayer.",
  usage: "Use it then you'll know.",
  cooldown: 3,
  permissions: [0, 1, 2],
  isAbsolute: false,
  isHidden: false,
  credits: "Sies",

}

const { api } = global;
async function onCall({ message, args, getLang, extra, data, userPermissions, prefix }) {
  // Do something
  try {
    const { senderID, threadID, messageID, body, send, reply, react } = message;
    const { Users } = global.controllers
    global.chanle || (global.chanle = new Map);
    var bcl = global.chanle.get(message.threadID);
    const anhbcl = (await axios.get("https://i.imgur.com/u7jZ2Js.jpg", {
      responseType: "stream"
    })).data;
    switch (args[0]) {
      case "create":
      case "new":
      case "-c": {
        // Check if the game has already started
        if (gameData.start) {
          return api.sendMessage("[SIES-WARN âš ] Â» The game has already started!", threadID, message.messageID);
        }

        if (!args[1] || isNaN(args[1])) {
          return api.sendMessage("[SIES-WARN âš ] Â» You need to enter a valid bet amount!", threadID, message.messageID);
        }

        const betAmount = parseInt(args[1]);
        const userMoney = await Users.getMoney(senderID) || 0;

        if (userMoney < betAmount) {
          return api.sendMessage(`[SIES-WARN âš ] Â» You don't have enough money to create a new game with a bet of â‚±${betAmount}!`, threadID, message.messageID);
        }

        gameData.moneyPool += betAmount;
        gameData.player.push({
          userID: senderID,
          bet: betAmount,
        });

        global.chanle.set(threadID, gameData);

        return api.sendMessage(`[SIES-NOTI] Â» Successfully created a game with a bet of â‚±${betAmount}.`, threadID);
      }
      case "join":
      case "-j": {
        // Check if the game has already started
        if (gameData.start) {
          return api.sendMessage("[SIES-WARN âš ] Â» The game has already started!", threadID, message.messageID);
        }

        if (gameData.player.find((player) => player.userID === senderID)) {
          return api.sendMessage("[SIES-WARN âš ] Â» You have already joined this game!", threadID, message.messageID);
        }

        const playerMoney = await Users.getMoney(senderID) || 0;

        if (playerMoney < gameData.moneyPool) {
          return api.sendMessage(`[SIES-WARN âš ] Â» You don't have enough money to join this game with a bet of â‚±${gameData.moneyPool}!`, threadID, message.messageID);
        }

        gameData.moneyPool += gameData.moneyPool; // Add the bet to the money pool
        gameData.player.push({
          userID: senderID,
          bet: gameData.moneyPool,
        });

        global.chanle.set(threadID, gameData);

        return api.sendMessage(`[SIES-NOTI] Â» Successfully joined the game with a bet of â‚±${gameData.moneyPool}.`, threadID);
      }
      case "start":
      case "-s": {
        // Check if the game has already started
        if (gameData.start) {
          return api.sendMessage("[SIES-WARN âš ] Â» The game has already started!", threadID, message.messageID);
        }

        if (gameData.player.length <= 1) {
          return api.sendMessage("[SIES-WARN âš ] Â» You need at least two players to start the game!", threadID, message.messageID);
        }

        // Randomly select 'Even' or 'Odd'
        const result = Math.random() < 0.5 ? "Even" : "Odd";

        // Determine the winners and losers
        const winners = gameData.player.filter((player) => (player.bet % 2 === 0 && result === "Even") || (player.bet % 2 !== 0 && result === "Odd"));
        const losers = gameData.player.filter((player) => !winners.includes(player));

        // Calculate the prize amount for each winner
        const prizePerWinner = gameData.moneyPool / winners.length;

        // Distribute prizes to winners
        for (const winner of winners) {
          const userMoney = await Users.getMoney(winner.userID) || 0;
          await Users.updateMoney(winner.userID, userMoney + prizePerWinner);
        }

        // Reset game data
        global.chanle.delete(threadID);

        // Notify the results
        api.sendMessage(`[SIES-NOTI] Â» Game has started!\nResult: ${result}\nWinners: ${winners.length} players\nPrize per winner: â‚±${prizePerWinner}`, threadID);

        return api.sendMessage("[SIES-NOTI] Â» The game has ended. The money has been distributed to the winners.", threadID);
      }
      case "end":
      case "-e":
        return bcl ? bcl.author != message.senderID ? global.api.sendMessage("[SIES-WARN âš ] Â» ğšˆğš˜ğš ğšŠğš›ğš ğš—ğš˜ğš ğšğš‘ğš ğšŒğš›ğšğšŠğšğš˜ğš› ğš˜ğš ğšğš‘ğš ğšğšŠğš–ğš ğšğšŠğš‹ğš•ğš, ğšœğš˜ ğš¢ğš˜ğš ğšŒğšŠğš—ğš—ğš˜ğš ğšğšğš•ğšğšğš ğšğš‘ğš ğšğšŠğš–ğš ğšğšŠğš‹ğš•ğš.", message.threadID, message.messageID) : (global.chanle.delete(message.threadID), global.api.sendMessage("[ SIES-NOTI ] Â» ğ™³ğšğš•ğšğšğšğš ğšğšŠğš–ğš ğš‹ğš˜ğšŠğš›ğš!", message.threadID, message.messageID)) : global.api.sendMessage("[SIES-WARN âš ] Â» ğšƒğš‘ğš’ğšœ ğšğš›ğš˜ğšğš™ ğšğš˜ğšğšœ ğš—ğš˜ğš ğš‘ğšŠğšŸğš ğšŠğš—ğš¢ ğšğšŠğš–ğš ğšğšŠğš‹ğš•ğšğšœ ğš¢ğšğš!\n=> ğ™¿ğš•ğšğšŠğšœğš ğšŒğš›ğšğšŠğšğš ğšŠ ğš—ğšğš  ğšğšŠğš–ğš ğšğšŠğš‹ğš•ğš ğšğš˜ ğš“ğš˜ğš’ğš—!", message.threadID, message.messageID);
      case "leave":
      case "-l":
        if (!global.chanle.has(message.threadID)) return api.sendMessage('[SIES-WARN âš ] Â» ğ™²ğšğš›ğš›ğšğš—ğšğš•ğš¢ ğšğš‘ğšğš›ğš ğšŠğš›ğš ğš—ğš˜ ğšğšŠğš–ğš ğšğšŠğš‹ğš•ğšğšœ ğšğš˜ğš› ğš¢ğš˜ğš ğšğš˜ ğš•ğšğšŠğšŸğš!', message.threadID, message.messageID);
        if (!bcl.player.find((player) => player.userID == message.senderID)) return api.sendMessage('[SIES-WARN âš ] Â» ğšˆğš˜ğš ğšğš˜ğš—â€™ğš ğš‘ğšŠğšŸğš ğšŠğš—ğš¢ ğšğšŠğš–ğšğšœ ğš•ğšğšğš!', threadID, messageID);
        if (bcl.start == true) return api.sendMessage('[SIES-WARN âš ] Â» ğšˆğš˜ğš ğšğš’ğšğš—â€™ğš ğšœğšğš ğšğš‘ğš ğšğšŠğš–ğš ğšğš’ğšœğšŠğš™ğš™ğšğšŠğš› ğš“ğšğšœğš ğšŠğšğšğšğš› ğšœğšğšŠğš›ğšğš’ğš—ğš!', threadID, messageID);
        if (bcl.author == message.senderID) {
          global.chanle.delete(message.threadID);
          const name = (await global.controllers.Users.getInfo(message.senderID))?.name || message.senderID;
          return global.api.sendMessage('[SIES-NOTI âš ] Â» â£ <' + name + '> ğš•ğšğšğš ğšğš‘ğš ğšğšŠğš–ğš’ğš—ğš ğšğšŠğš‹ğš•ğš, ğšğš‘ğšğš’ğš› ğšğšŠğš–ğš’ğš—ğš ğšğšŠğš‹ğš•ğš ğš ğš’ğš•ğš• ğš‹ğš ğšğš’ğšœğšŒğš˜ğšğš—ğšğšğš!', message.threadID, message.messageID);
        }
        else {
          bcl.player.splice(bcl.player.findIndex((player) => player.userID == message.senderID), 1);
          global.chanle.set(message.threadID, bcl);
          const name = (await global.controllers.Users.getInfo(message.senderID))?.name || message.senderID;
          global.api.sendMessage('[SIES-NOTI] Â» ğ™¼ğš˜ğšğšœğš ğšğšŠğš•ğš•ğšœ ğš˜ğšğš ğšğš‘ğš ğšğšŠğš‹ğš•ğš!', message.threadID, message.messageID);
          return global.api.sendMessage('[ SIES-NOTI ] Â»â£ <' + name + '> left the gaming table!\n=> ğšƒğš‘ğšğš’ğš› ğšğšŠğš–ğš’ğš—ğš ğšğšŠğš‹ğš•ğš ğš ğš’ğš•ğš• ğš‹ğš ğšğš’ğšœğšŒğš˜ğšğš—ğšğšğš.' + bcl.player.length + ' ğ™¿ğš•ğšŠğš¢ğšğš› ', message.threadID);
        }
        
      default:
        return global.api.sendMessage({
          body: "==ã€Multiplayer Odd and Even Playã€‘==\n1. !eo -c/create <price> => To create a room.\n2. !eo -j/join => Join to enter the room. \n3. !eo -s/start => To start the game.\n4. !eo -l/leave => To leave the game.\n5. !eo -e/end => To end the game.",
          attachment: anhbcl
        }, message.threadID, message.messageID)
    }
  } catch (e) {
    message.send("Error :", e);
    console.error(e);
  }

}


export default {
  config,
  onCall
}

// or
// export {
//     config,
//     langData,
//     onCall
// }